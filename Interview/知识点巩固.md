# 语言基础



# 操作系统

* 如何解决线程池里的惊群问题？
  * **惊群问题是指在多线程（多进程）下，有多个线程在等待同一资源，当该资源可用时， 所有等待的线程都被唤醒**。
  * `accept`惊群，`epoll`惊群。
  * *Nginx*规定同一时刻只能有一个*worker*子进程监听端口，此时新连接事件只能唤醒一个进程，通过`accept_mutex`实现。
  * 任意时刻只有一个进程能获得`accept_mutex`锁，获得`accept_mutex`锁的进程能监听*web*端口；无法获得`accept_mutex`锁的进程会把监听套接字从其`epoll`中删除。
* `Reactor`和`Proactor`
  * Reactor 模式主要由 Reactor 和处理资源池这两个核⼼部分组成，它俩负责的事情如下：
    * Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件。
    * 处理资源池负责处理事件，如 read -> 业务逻辑 -> send。
  * Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：
    * Reactor 的数量可以只有⼀个，也可以有多个。
    * 处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程。
  * 将上⾯的两个因素排列组设⼀下，理论上就可以有 4 种⽅案选择：
    * **单 Reactor 单进程 / 线程**
    * **单 Reactor 多进程 / 线程**
    * ~~多 Reactor 单进程 / 线程~~
    * **多 Reactor 多进程 / 线程**
  * 其中，「多 Reactor 单进程 / 线程」实现⽅案相⽐「单 Reactor 单进程 / 线程」⽅案，不仅复杂⽽且也没有性能优势，因此实际中并没有应⽤。剩下的 3 个⽅案都是⽐较经典的，且都有应⽤在实际的项⽬中。  
  * 单Reactor单进程
    * Reactor 对象通过 select （IO 多路复⽤接⼝） 监听事件，收到事件后通过 dispatch 进⾏分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型。
    * 如果是连接建⽴的事件，则交由 Acceptor 对象进⾏处理， Acceptor 对象会通过 accept ⽅法 获取连接，并创建⼀个 Handler 对象来处理后续的响应事件；如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应。
    * Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。
    * 单 Reactor 单进程的⽅案因为全部⼯作都在同⼀个进程内完成，所以实现起来⽐较简单，不需要考虑进程间通信，也不⽤担⼼多进程竞争。但是，这种⽅案存在 2 个缺点：
      * 因为只有⼀个进程， ⽆法充分利⽤ 多核 CPU 的性能。
      *  Handler 对象在业务处理时，整个进程是⽆法处理其他连接的事件的， 如果业务处理耗时⽐较⻓，那么就造成响应的延迟。
    * 所以，单 Reactor 单进程的⽅案不适⽤计算机密集型的场景，只适⽤于业务处理⾮常快速的场景。
    * `Redis` 是由 C 语⾔实现的，它采⽤的正是「单 Reactor 单进程」的⽅案，因为 `Redis` 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 `Redis` 对于命令的处理是单进程的⽅案 。
  * 单Reactor多进程/线程
    * 单Reactor多线程
      * Reactor 对象通过 select （IO 多路复⽤接⼝） 监听事件，收到事件后通过 dispatch 进⾏分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型。
      * 如果是连接建⽴的事件，则交由 Acceptor 对象进⾏处理， Acceptor 对象会通过 accept ⽅法 获取连接，并创建⼀个 Handler 对象来处理后续的响应事件；如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应。**上⾯的三个步骤和单 Reactor 单线程⽅案是⼀样的，接下来的步骤就开始不⼀样了**。
      * Handler 对象不再负责业务处理，只负责数据的接收和发送， Handler 对象通过 read 读取到数据后，会将数据发给⼦线程⾥的 Processor 对象进⾏业务处理。
      * ⼦线程⾥的 Processor 对象就进⾏业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send ⽅法将响应结果发送给 client。
    * 单 Reactor 多线程的⽅案优势在于能够充分利⽤多核 CPU 的能，那既然引⼊多线程，那么⾃然就带来了多线程竞争资源的问题。
      * ⼦线程完成业务处理后，要把结果传递给主线程的 Reactor 进⾏发送，这⾥涉及共享数据的竞争。
      * 要避免多线程由于竞争共享资源⽽导致数据错乱的问题，就需要在操作共享资源前加上互斥锁，以保证任意时间⾥只有⼀个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。  
    * 单Reactor多进程
      * 事实上，单 Reactor 多进程相⽐单 Reactor 多线程实现起来很麻烦，主要因为要考虑⼦进程 <-> ⽗进程的双向通信，并且⽗进程还得知道⼦进程要将数据发送给哪个客户端。
      * ⽽多线程间可以共享数据，虽然要额外考虑并发问题，但是这远⽐进程间通信的复杂度低得多，因此实际应⽤中也看不到单 Reactor 多进程的模式。
      * 另外，「单 Reactor」的模式还有个问题，**因为⼀个 Reactor 对象承担所有事件的监听和响应，⽽且只在主线程中运⾏，在⾯对瞬间⾼并发的场景时，容易成为性能的瓶颈的地⽅**。  
  * 多Reactor多线程
    * 要解决「单 Reactor」的问题，就是将「单 Reactor」实现成「多 Reactor」，这样就产⽣了多Reactor 多进程 / 线程的⽅案。
      * 主线程中的 `MainReactor` 对象通过 select 监控连接建⽴事件，收到事件后通过 Acceptor 对象中的accept 获取连接，将新的连接分配给某个⼦线程。
      * ⼦线程中的 `SubReactor` 对象将 `MainReactor` 对象分配的连接加⼊ select 继续进⾏监听，并创建⼀个Handler ⽤于处理连接的响应事件。
        如果有新的事件发⽣时， `SubReactor` 对象会调⽤当前连接对应的 Handler 对象来进⾏响应。
      * Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。
    * 多 Reactor 多线程的⽅案虽然看起来复杂的，但是实际实现时⽐单 Reactor 多线程的⽅案要简单的多，原因如下：
      * 主线程和⼦线程分⼯明确，主线程只负责接收新连接，⼦线程负责完成后续的业务处理。
      * 主线程和⼦线程的交互很简单，主线程只需要把新连接传给⼦线程，⼦线程⽆须返回数据，直接就可以在⼦线程将处理结果发送给客户端。
    * ⼤名鼎鼎的两个开源软件 `Netty` 和 `Memcache` 都采⽤了「多 Reactor 多线程」的⽅案。采⽤了「多 Reactor 多进程」⽅案的开源软件是 Nginx，不过⽅案与标准的多 Reactor 多进程有些差异。
    * 具体差异表现在主进程中仅仅⽤来初始化 socket，并没有创建 `MainReactor` 来 accept 连接，⽽是由⼦进程的 Reactor 来 accept 连接，通过锁来控制⼀次只有⼀个⼦进程进⾏ accept（防⽌出现惊群现象），⼦进程 accept 新连接后就放到⾃⼰的 Reactor 进⾏处理，不会再分配给其他⼦进程。  
  * `Reactor` 是⾮阻塞同步⽹络模式，⽽ `Proactor` 是异步⽹络模式。异步 I/O ⽐同步 I/O 性能更好，因为异步 I/O 在「内核数据准备好」和「数据从内核空间拷⻉到⽤户空间」这两个过程都不⽤等待。`Proactor` 正是采⽤了异步 I/O 技术，所以被称为异步⽹络模型。
  * 现在我们再来理解 `Reactor` 和 `Proactor` 的区别，就⽐较清晰了。
    * `Reactor` 是**非阻塞同步网络模式，感知的是就绪可读写事件**。在每次感知到有事件发⽣（⽐如可读就绪事件）后，就需要应⽤进程主动调⽤ read ⽅法来完成数据的读取，也就是要应⽤进程主动将socket 接收缓存中的数据读到应⽤进程内存中，这个过程是同步的，读取完数据后应⽤进程才能处理数据。
    * `Proactor` 是**异步网络模式， 感知的是已完成的读写事件**。在发起异步读写请求时，需要传⼊数据缓冲区的地址（⽤来存放结果数据）等信息，这样系统内核才可以⾃动帮我们把数据的读写⼯作完成，这⾥的读写⼯作全程由操作系统来做，并不需要像 Reactor 那样还需要应⽤进程主动发起read/write来读写数据，操作系统完成读写⼯作后，就会通知应⽤进程直接处理数据。    
* 什么是零拷贝？
  * **直接内存访问（Direct Memory Access）** 技术。简单理解就是， 在进⾏ I/O 设备和内存的数据传输的时候，**数据搬运的⼯作全部交给DMA 控制器，⽽ CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。**  
  * 传统的⽂件传输⽅式会历经 4 次数据拷⻉，⽽且这⾥⾯，「从内核的读缓冲区拷⻉到⽤户的缓冲区⾥，再从⽤户的缓冲区⾥拷⻉到 socket 的缓冲区⾥」，这个过程是没有必要的。因为⽂件传输的应⽤场景中，在⽤户空间我们并不会对数据「再加⼯」，所以数据实际上可以不⽤搬运到⽤户空间，因此**⽤户的缓冲区是没有必要存在的**。  
  * 零拷贝技术实现的⽅式通常有 2 种：
    * `mmap` + `write`：用`mmap`替换`read`，减少一次数据拷贝，但是系统调用还是四次。
    * `sendfile`：替代`read`和`write`，减少两次数据拷贝，系统调用为三次。
  * 从 Linux 内核 2.4 版本开始起，对于⽀持⽹卡⽀持 SG-DMA 技术的情况下， `sendfile` 系统调⽤的过程发⽣了点变化，具体过程如下：
    * 第⼀步，通过 DMA 将磁盘上的数据拷⻉到内核缓冲区⾥；
    * 第⼆步，缓冲区描述符和数据⻓度传到 socket 缓冲区，这样⽹卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷⻉到⽹卡的缓冲区⾥，此过程不需要将数据从操作系统内核缓冲区拷⻉到 socket缓冲区中，这样就减少了⼀次数据拷⻉。所以，这个过程之中，只进⾏了 2 次数据拷⻉。

# 计算机网络

* OSI七层模型
    |OSI七层模型|功能|协议|设备|
    |:---|--- |---|---|
    |应用层|为用户提供服务，如操作界面。|**HTTP**,FTP,**DNS**,POP3, SMTP||
    |表示层|对数据进行表示、加密和压缩等。|JPEG,ASCII,PICT||
    |会话层|确定数据是否需要网络传递。|**SQL**,NFS,NetBIOS||
    |传输层|对报文进行分组、封装和校验等。|**TCP**,**UDP**|四层路由器，四层交换机|
    |网络层|IP地址寻址，路由选择等。|**ARP**,**RARP**,**IP**,**ICMP**|路由器，三层交换机|
    |数据链路层|MAC地址寻址。|IEEE802.2/802.3,HDLC|网桥，以太网交换机，网卡|
    |物理层| 数据的实际传输，电气特性定义。|PPP,SLTP|中继器，集线器，双绞线|
    * 四层交换机和三层交换机区别：三层交换机就是具有部分路由器功能的交换机，三层交换机的最重要目的是加快大型局域网内部的数据交换，能够做到一次路由，多次转发。基于MAC地址和IP地址的交换机技术，能够极大地提高各节点之间的数据传输率，但却无法根据端口主机的应用需求来自主确定或动态限制端口的交换过程和数据流量。第四层交换机不仅可以完成端到端交换，还能根据端口主机的应用特点，确定或限制它的交换流量。是基于传输层数据包的交换过程的，是一类基于TCP/IP协议应用层的用户应用交换需求的新型局域网交换机。支持TCP/UDP第四层以下的所有协议，可识别至少80个字节的数据包包头长度，可根据TCP/UDP端口号来区分数据包的应用类型，从而实现应用层的访问控制和服务质量保证。所以，与其说第四层交换机是硬件网络设备，还不如说它是软件网络管理系统

* 局域网A主机访问局域网B主机，过程是怎样的？
  * 有交换机，无路由器
    * 只能在同一个网段下访问，交换机中包含*MAC*地址表，查到目的*IP*对应的MAC地址则直接发送。
    * 没有则发送*ARP*广播，更新交换机中的*MAC*地址表。
  * 有交换机，有路由器
    * 同一网段的走交换机，不同网段的走路由器，因为本机不知道目的*IP*对应的*MAC*地址。
    * 链路层封装时，源*MAC*为本机*MAC*，目的*MAC*为路由器*MAC*。
    * 数据包到达路由器后，解包再封装，源*MAC*为路由器*MAC*，目的*MAC*下一跳路由*MAC*。
  * 没有对应的*MAC*地址则丢弃数据包。
  
* 交换机和路由器工作在哪一层？
  * **交换机**通过*MAC*进行寻址，所以工作在**数据链路层**。
  * **路由器**通过*IP*进行寻址，所以工作在**网络层**。
  
* `kqueue`和`epoll`的区别？

    * 都是I/O多路复用技术，但`kqueue`是Mac OS的，`epoll`是Linux的。
    * 注意`kqueue`与`epoll`最大的不同在于`read`/`write`事件是分开注册并且分开返回的，而`epoll`则是一个`fd`一次返回读和写事件，用标志位来判断。

# 数据库

* `Redis`常用数据结构
  * 简单动态字符串`SDS`
    * `SDS`等同于C语言中的`char * `，但它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结束，因此它必然有个长度字段。
    * 获取字符串长度的复杂度为O(1)。
    * 杜绝缓冲区溢出，减少修改字符串长度时所需要的内存重分配次数。
    * 二进制安全，兼容部分C字符串函数。
    * 它具有很常规的 set/get 操作，value 可以是String也可以是数字，一般做一些复杂的计数功能的缓存。
  * 链表`list`
    * 当有一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，`Redis`就会使用链表作为列表建的底层实现。
    * 链表被广泛用于实现`Redis`的各种功能，比如列表建、发布与订阅、慢查询、监视器等。
    * 每个链表节点由一个`listNode`结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以`Redis`的链表实现是**双端链表**。
    * 每个链表使用一个list结构表示，这个结构带有**表头节点指针**、**表尾节点指针**，以及**链表长度**等信息。
    * 因为链表表头的前置节点和表尾节点的后置节点都指向NULL，所以`Redis`的链表实现是**无环链表**。
    * 通过为链表设置不同的类型特定函数，`Redis`的链表可以用于保存各种不同类型的值。
  * 字典
    * 当字典被用作数据库的底层实现，或者哈希键的底层实现时，`Redis`使用`MurmurHash`算法。这种算法的优点在于即使输入的键是规律的，算法仍能给出一个个很好的随机分布性，并且算法的计算速度非常快。
    * `Redis`的哈希表使用**链地址法来解决键冲突**，每个哈希表节点都有一个next指针，多个哈希表节点可以用这个单向链表连接起来，这就解决了键冲突的问题。
    * 字典被广泛用于实现`Redis`的各种功能，其中包括数据库和哈希键。
    * `Redis`中的字典使用哈希表作为底层结构实现，每个字典带有**两个哈希表**，一个**平时使用**，另一个仅在进行**rehash时使用**。
    * `Redis`使用MurmurHash2算法来计算键的哈希值，使用链地址法来解决键冲突。
  * 跳表`skiplist`
    * 跳跃表是有序集合的底层实现之一
    * `Redis`的跳跃表实现由`zskiplist`和`zskiplistNode`两个结构组成，其中`zskiplist`用于保存跳跃表信息（比如表头节点、表尾节点、长度），而`zskiplistNode`则用于表示跳跃表节点
    * 每个跳跃表节点的层高都是1至32之间的随机数
    * 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
    * 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。
    * 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现。
  * 压缩列表
    * 压缩列表`ziplist`是列表键和哈希键的底层实现之一。
    * 当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么`Redis`就会使用压缩列表来做列表键的底层实现。
* 单线程的`Redis`为什么这么快？
  * `Redis`的全部操作都是纯内存的操作。
  * `Redis`采用单线程，有效避免了频繁的上下文切换。
  * 采用了非阻塞I/O多路复用机制。
* 了解`Redis`的线程模型吗？可以大致说说吗？
  * `Redis`内部使用文件事件处理器`file event handler`，这个文件事件处理器是单线程的，所以`Redis`才叫做单线程的模型。
  * 它采用 I/O 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。
  * 文件事件处理器的结构包含 4 个部分：
    - 多个 socket
    - IO多路复用程序
    - 文件事件分派器
    - 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
  * 使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。
  * 多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。
  * 一句话总结就是：**“I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。”**
* 在`innodb` RR级别下，select * from user where id = 10 for update会触发什么锁？如何id=10不存在的情况下会触发什么锁呢？
  * `MySQL` 里除了**普通查询是快照度**，其他都是**当前读**，比如`update`、`insert`、`delete`，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。`select ... for update` 这种查询语句是当前读，每次执行的时候都是读取最新的数据。
  * `Innodb` 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了`next-key`锁，就是记录锁和间隙锁的组合。
    - 记录锁，锁的是记录本身；
    - 间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。
  * `next-key` 锁的是索引，而不是数据本身，所以如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行加上了行锁，还给行两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。
  * id=10不存在的情况下会触发表级锁，全表扫描。

# Linux命令

* 查看摸个进程打开的文件和文件描述符。
  * 先使用`ps -ux`查看进程PID。
  * 使用`lsof -p 1430`（进程PID）。
  * 也可以使用 `ll proc/1430/fd`，查看打开的文件描述符。
* 结束一个进程（如tomcat)
  * `ps -ef|grep tomact`查找进程PID
  * `kill -9 PID`强制结束进程。
* Linux 如何查看一个进程的堆栈
  * stack 进程ID
  * 使用`gdb` 然后attach 进程ID，然后再使用命令 thread apply all bt



# 云计算

* **IaaS**，**PaaS**，**SaaS** 的区别

  * **IaaS**：基础设施服务，Infrastructure-as-a-service
  * **PaaS**：平台服务，Platform-as-a-service
  * **SaaS**：软件服务，Software-as-a-service

* `iptables`

  * **iptables只是一个用户空间的程序，真正干活的其实是Linux内核`netfilter`，通过iptables创建新规则，其实就是在`netfilter`中插入一个`hook`，从而实现修改数据包、控制数据包流向等。**
  
  ```mermaid
    graph LR
    	id1(数据包入口) --PREROUTING--> id2(路由判断)
    	id2 --INPUT--> id3(上层协议栈)
    	id3 --OUTPUT--> id4(数据发出)
    	id4 --POSTROUTING--> id5(数据包出口)
    	id2 --FORWARD--> id4
    	
  ```
  
  * `iptables`通过规则匹配决定包的去向，**规则由匹配条件+动作构成**，规则通过-I、-A插入。
  * **五链五表**，五链为`PREROUTING`、`INPUT`、`FORWARD`、`OUTPUT`、`POSTROUTING`，五表为`raw`、`mangle`、`nat`、`filter`、`security`。链、表、规则都是有顺序的。
  
  * 当链中的所有规则都不匹配时，iptables会根据链设置的默认策略policy处理包，通过policy设置为ACCEPT，不建议配置为DROP。
  * 可以创建子链挂在内置链中，子链的policy为RETURN，不支持配置。
  
  * 匹配条件包括基本匹配条件以及扩展模块提供的扩展匹配条件，扩展匹配条件通过-m参数加载，需要记住的扩展模块为comment、tcp、udp、icmp、mac、state、physdev、set。
  * 常见的`iptables`动作(`target`)为`ACCEPT`、`DROP`、`RETURN`、`LOG`以及`跳转到子链`。
  
* **安全组规则挂在iptables哪条链？**

  * 根据前面的基础，不难猜出安全组的`iptables`规则肯定是在`filter`表实现的，`filter`表只涉及`INPUT`、`FORWARD`、`OUTPUT`三条链。
  * 做过主机防火墙的可能第一直觉会认为安全组规则会挂在`INPUT`以及`OUTPUT`链上，但如果包不是发给自己的，根本到不了`INPUT`以及`OUTPUT`，因此显然在`INPUT`、`OUTPUT`根本实现不了安全组规则，因此安全组的`iptables`规则肯定是在`FORWARD`链上实现的，也就是说计算节点不处理虚拟机的包（发给自己的包除外），只负责转发包。
